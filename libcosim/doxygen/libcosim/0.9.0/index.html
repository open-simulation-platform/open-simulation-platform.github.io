<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcosim: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcosim<span id="projectnumber">&#160;0.9.0</span>
   </div>
   <div id="projectbrief">C++ library for distributed co-simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The <a href="https://open-simulation-platform.github.io/libcosim">libcosim</a> API can roughly be divided into two parts, corresponding to the main phases of a co-simulation. These are:</p>
<ul>
<li>The <em>setup phase</em>, which is everything that happens before you actually run a simulation, such as reading configuration files, loading FMUs, setting up the system for simulation, and so on.</li>
<li>The <em>execution phase</em>, where we run a simulation, solving the model equations, logging and/or displaying output, et cetera.</li>
</ul>
<p >These phases are not distinguished in any particular way in the API. Most symbols simply live in the top-level <code>#cosim</code> namespace, and there is no specific naming convention to set them apart. Nor are they entirely distinct in functionality, as several classes and functions are used in both phases. Nevertheless, the distinction between "setup" and "execution" provides a good framework for learning and understanding the libcosim API.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Setting up a simulation</h2>
<p >The central class in the setup phase is <code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code>. This contains a representation of the modelled system, consisting of the entities (simulators and functions) in it and the connections between them. It requires a description of each simulator or function, which must be given in the form of a <code><a class="el" href="classcosim_1_1model.html" title="A model, i.e., a blueprint from which slaves can be instantiated.">cosim::model</a></code> or <code><a class="el" href="classcosim_1_1function__type.html" title="Interface for classes that represent function types and act as factory classes for function instances...">cosim::function_type</a></code> object, respectively. At this stage, the entities themselves are not instantiated, so no simulator/function code is actually run.</p>
<p >You can build the system structure from scratch, starting with an empty <code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code> object, or you can read it from a file. libcosim supports two file formats:</p>
<ul>
<li>The <a href="https://opensimulationplatform.com/specification/">Open Simulation Platform Interface Specification</a> (OSP-IS) system structure format, which we consider our "native" format and therefore support fully. Use <code><a class="el" href="namespacecosim.html#a6c1c97ded1908aadabe697ca44393e4c" title="Loads an OSP-IS system structure file.">cosim::load_osp_config()</a></code> to read OSP-IS system structure files.</li>
<li>The <a href="https://ssp-standard.org/">System Structure &amp; Parametrization</a> (SSP) format, for which we have limited support, but which we aim to support more fully in the future. Use <code><a class="el" href="classcosim_1_1ssp__loader.html" title="Class for loading an execution from a SSP configuration.">cosim::ssp_loader</a></code> to read SSP files.</li>
</ul>
<p >In both of these formats, the models used in the simulation are specified by URIs that point to FMUs. These URIs need to be converted into <code><a class="el" href="classcosim_1_1model.html" title="A model, i.e., a blueprint from which slaves can be instantiated.">cosim::model</a></code> objects that represent the FMUs in question. This is the job of a <code><a class="el" href="classcosim_1_1model__uri__resolver.html" title="A generic model URI resolver.">cosim::model_uri_resolver</a></code>, and usually, you should start with the one created by <code><a class="el" href="namespacecosim.html#a346b1b1dc859e6aa78829cf8e88b02ba" title="Returns a resolver for all URI schemes supported natively by libcosim.">cosim::default_model_uri_resolver()</a></code>. You can customise it with support for additional URI schemes if necessary.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Executing a simulation</h2>
<p >The central class in the execution phase is <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code>. It manages the entities involved in a single co-simulation run (i.e., an <em>execution</em>) and provides a high-level interface for driving the simulation process.</p>
<p >By far, the easiest way to set up an execution is to first create a <code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code>, as described above, and inject this structure into an empty <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> using <code><a class="el" href="namespacecosim.html#a23555ee4044545cbee853370280f76c2" title="Adds simulators and connections to an execution, and sets initial values, according to a predefined s...">cosim::inject_system_structure()</a></code>. However, it is also possible to build the execution "by hand" by adding simulators and functions to it in the form of <code><a class="el" href="classcosim_1_1slave.html" title="An interface for classes that represent co-simulation slaves.">cosim::slave</a></code> and <code><a class="el" href="classcosim_1_1function.html" title="An interface for function instances.">cosim::function</a></code> objects, respectively.</p>
<p >When would you choose which method? Starting with <code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code> has several advantages:</p>
<ul>
<li><code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code> refers to entities by <em>name</em>, whereas <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> refers to them by numeric IDs.</li>
<li>A single <code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code> can be used to set up multiple <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> objects. This is useful in many cases, for example if you want to simulate the same system with different initial conditions.</li>
<li><code><a class="el" href="classcosim_1_1system__structure.html" title="A description of the structure of a modelled system.">cosim::system_structure</a></code> only requires entity <em>descriptions</em>, whereas <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> requires actual entity instances. This has practical and performance-related implications, in that the latter could entail loading of DLLs with model code, and even network communication in the case of distributed co-simulations.</li>
</ul>
<p >However, if you only need to run a single simulation and therefore need to instantiate all entities exactly once anyway, and you are OK with using numerical indices to manipulate them (which you must, anyway, once the execution is up and running), then reaching straight for <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> may be the right thing to do.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Getting results</h3>
<p >To obtain the results of an execution, i.e. the values of various simulator variables at various times, create an <em>observer</em>. More specifically, add a <code><a class="el" href="classcosim_1_1observer.html" title="An interface for observers.">cosim::observer</a></code> object using <code><a class="el" href="classcosim_1_1execution.html#a66acd12770ba37343e0cb0728b8aa8a9" title="Adds an observer to the execution.">cosim::execution::add_observer()</a></code>. The <code><a class="el" href="classcosim_1_1observer.html" title="An interface for observers.">cosim::observer</a></code> interface is designed to support many use cases, from file output to real-time visualisation.</p>
<p >libcosim itself supplies three implementations of this interface, namely:</p>
<ul>
<li><code><a class="el" href="classcosim_1_1file__observer.html" title="An observer implementation, for saving observed variable values to file in csv format.">cosim::file_observer</a></code>, which logs output to CSV files</li>
<li><code><a class="el" href="classcosim_1_1time__series__observer.html" title="An observer implementation, storing all observed variable values for a user-specified set of variable...">cosim::time_series_observer</a></code>, which buffers time series in memory</li>
<li><code><a class="el" href="classcosim_1_1last__value__observer.html" title="An observer implementation, storing the last observed variable values in memory.">cosim::last_value_observer</a></code>, which simply keeps track of the most recent variable values.</li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
Manipulating the system</h3>
<p >Sometimes, you need to influence the simulation in some way. This could be to change parameters, override variable values, or even transform them in more or less subtle ways. In libcosim, this is done via the <code><a class="el" href="classcosim_1_1manipulator.html" title="An interface for manipulators.">cosim::manipulator</a></code> interface.</p>
<p ><code><a class="el" href="classcosim_1_1manipulator.html" title="An interface for manipulators.">cosim::manipulator</a></code> is very similar to <code><a class="el" href="classcosim_1_1observer.html" title="An interface for observers.">cosim::observer</a></code>, but where the latter merely has a read-only view of the system, a manipulator has much extended powers. More precisely, a <code><a class="el" href="classcosim_1_1manipulator.html" title="An interface for manipulators.">cosim::manipulator</a></code> can apply <em>any transformation</em> to <em>any variable</em> in the system.</p>
<p >libcosim supplies two manipulators:</p>
<ul>
<li><code><a class="el" href="classcosim_1_1override__manipulator.html" title="A manipulator implementation handling overrides of variable values.">cosim::override_manipulator</a></code>, which, as the name suggests, lets you override the value of any variable with a value of your choosing.</li>
<li><code><a class="el" href="classcosim_1_1scenario__manager.html" title="A manipulator implementation handling execution and control of scenarios.">cosim::scenario_manager</a></code>, which manipulates variables according to a given <em>scenario</em>.</li>
</ul>
<p >A scenario can be loaded from a <a href="https://open-simulation-platform.github.io/libcosim/scenario">file</a>, or it can be specified in code as a <code><a class="el" href="structcosim_1_1scenario_1_1scenario.html" title="A struct representing an executable scenario.">cosim::scenario::scenario</a></code> object. In both cases, it consists of a series of <em>events</em> that occur at predetermined times. At each event, some variable is modified in some way.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Changing the algorithm</h3>
<p >Under the hood, <code><a class="el" href="classcosim_1_1execution.html" title="A class which represents an execution, i.e., a co-simulation run.">cosim::execution</a></code> delegates much of its responsibilities to a <em>co-simulation algorithm</em> (sometimes called <em>master</em> algorithm). These responsibilities include:</p>
<ul>
<li>Deciding when to step various simulators forward in time, and how far</li>
<li>Keeping simulators synchronised in time</li>
<li>Routing data between simulators</li>
</ul>
<p >In libcosim, a co-simulation algorithm must be implemented as a subclass of the <code><a class="el" href="classcosim_1_1algorithm.html" title="An interface for co-simulation algorithms.">cosim::algorithm</a></code> interface.</p>
<p >There exist several co-simulation algorithms, and libcosim has been designed to support even the more advanced ones. The library itself provides only one option: <code><a class="el" href="classcosim_1_1fixed__step__algorithm.html" title="A fixed-stepsize co-simulation algorithm.">cosim::fixed_step_algorithm</a></code>. For the most part, this is a rather simple, fixed-step (i.e., non-adaptive) algorithm. However, it has a nice extra feature in that it allows the use of different step sizes for different simulators, as long as they're all multiples of the same base step size.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Customising libcosim</h2>
<p >The library was designed with a large number of use cases in mind, but we are only able to support so many of them out of the box. If there is something you need to do, and there is no way to do it with libcosim's built-in functionality, you may be able to achieve it by <em>extending</em> libcosim in various ways.</p>
<p >Here is a list of some important customisation points. All of these are interfaces (pure virtual classes) of which you can make your own implementations. Many have already been mentioned, but we list them again for completeness and ease of reference:</p>
<ul>
<li><code><a class="el" href="classcosim_1_1algorithm.html" title="An interface for co-simulation algorithms.">cosim::algorithm</a></code> – to implement alternative co-simulation algorithms</li>
<li><code><a class="el" href="classcosim_1_1observer.html" title="An interface for observers.">cosim::observer</a></code> – to implement your own observers</li>
<li><code><a class="el" href="classcosim_1_1manipulator.html" title="An interface for manipulators.">cosim::manipulator</a></code> – to implement your own manipulators</li>
<li><code><a class="el" href="classcosim_1_1model.html" title="A model, i.e., a blueprint from which slaves can be instantiated.">cosim::model</a></code> and <code><a class="el" href="classcosim_1_1slave.html" title="An interface for classes that represent co-simulation slaves.">cosim::slave</a></code> – to implement simulators that don't necessarily come in the form of FMUs</li>
<li><code><a class="el" href="classcosim_1_1function__type.html" title="Interface for classes that represent function types and act as factory classes for function instances...">cosim::function_type</a></code> and <code><a class="el" href="classcosim_1_1function.html" title="An interface for function instances.">cosim::function</a></code> – to implement additional function types</li>
<li><code><a class="el" href="classcosim_1_1model__uri__sub__resolver.html" title="An interface for classes that resolve model URIs of one or more specific URI schemes.">cosim::model_uri_sub_resolver</a></code> – to implement support for additional model URI schemes</li>
<li><code><a class="el" href="classcosim_1_1file__cache.html" title="An interface to a file cache.">cosim::file_cache</a></code> – to change the way libcosim caches files (such as the unpacked contents of FMUs) </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
